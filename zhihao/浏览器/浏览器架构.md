## CPU GPU 
GPU最开始是用来处理图像，这就是为什么使用GPU可以更快、更顺畅的渲染页面内容。

## 计算机架构 硬件 操作系统 应用

## 进程和线程
1、一个进程是应用正则运行的程序，而线程是进程中更小的一部分。
2、当应用被启动，进程就被创建出来
3、操作系统会为进程分配私有的内存空间，当程序关闭之后，这段内存也会被释放

4、比线程还小的存在就是协程

## 进程间通信（IPC）
两个进程之间通信，需要用到的是IPC

## 浏览器架构
单进程：
多进程：
利用IPC实现多进程，多线程架构

## 进程工作内容
### 浏览器进程Browser process
浏览器进程负责管理Chrome应用本身，包括地址栏、书签、前进和后退按钮。同时也负责可不见的功能，比如网络请求、文件按访问等，也负责其他进程的调度。
### 渲染进程Renderer process
渲染进程负责站点的渲染，其中也包括JavaScript代码的运行，web worker的管理等。
### 插件进程
插件进程负责为浏览器提供各种额外的插件功能，例如flash。
### GPU进程
GPU进程负责提供成像的功能

## 多进程架构的好处
Chrome为每个站点创建一个独立的渲染进程，专门处理当前站点的渲染工作。如果所有的页面运行在同一个进程中，当有一个页面没有响应时，所有的页面就都卡住了。


另一个好处是，借助操作系统对进程安全的控制，浏览器可以将页面放置在沙箱中，站点的代码可以运行在隔离的环境中，保证核心进程的安全。

当使用多个页签访问相同的站点时浏览器不会创建新的渲染进程。

## 基于站点隔离的渲染进程
利用iframe我们可以在同一个页面访问不同站点的资源，但从安全的角度考虑，同源策略不允许一个站点在站点在未得到同意的情况下访问其他站点的资源，所以从Chrome 67开始每个站点由独立的渲染进程处理被默认启用。

## 浏览器进程：处理除了渲染外的大部分工作，浏览器进程包括几个线程：

- UI 线程负责绘制工具栏中的按钮、地址栏等。

- 网络线程负责从网络中获取数据。

- 存储线程负责文件等功能。


当我们在地址栏中输入一个地址时，浏览器进程中的UI线程最先得知这个动作，并开始处理。

# 一次访问 逐步了解浏览器是如何展示页面的

## step1 输入处理
当我们在地址栏输入时，UI线程会判断我们输入的内容是搜索的内容还是访问一个站点，因为地址栏同时也是搜索框。

## step2 访问开始
UI线程借助网络线程访问站点资源，网络线程会根据适当的网络协议，为这次请求建立连接；

当服务器返回给浏览器重定向请求时，网络线程会通知UI线程需要重定向，然后会以新的地址做开始请求资源。

## step3 处理响应数据
当网络线程收到服务器的数据时，会试图从数据中的前面的一些字节得到数据的类型（Content-Type），以试图了解数据的格式。

当返回的数据类型是HTML时，会将数据传递给渲染进程做进一步的渲染工作。但是如果数据类型是zip文件或者其他文件格式时，会将数据传递给下载管理器做进一步的文件预览或者下载工作。

**在开始渲染之前，网络线程要先检查数据的安全性，这里也是浏览器保证安全的地方**
同时，Cross Origin Read Blocking(CORB)策略也会确保跨域的敏感数据不会被传递给渲染进程。

## step4 渲染过程
当所有的检查结束后，网络线程确信浏览器可以访问站点时，网络线程通知UI线程数据已经准备好了。
UI线程会根据当前的站点找到一个渲染进程完成接下来的渲染工作

## step5 提交访问
数据和渲染进程都已经准备好了，浏览器进程会通过IPC向渲染进程提交这次访问，同时也会保证渲染进程可以通过网络线程继续获取数据。一旦浏览器进程收到来自渲染进程的确认完毕的消息，就意味着访问的过程结束了，文档渲染的过程就开始了。

## step6加载完毕


# 访问不同的站点


# 渲染进程赋值页面的内容
在一个渲染进程中，主线程负责解析，编译或运行代码等工作，当我们使用Worker时，Worker线程会负责运行一部分代码。**合成线程和光栅线程**是也是运行在渲染进程中的，负责更高效和顺畅的渲染页面。

渲染进程最重要的工作就是将HTML、CSS和Javascript代码转换成一个可以与用户产生交互的页面。


## 解析过程
## DOM创建
主线程开始解析HTML文本字符串，并且将其转化成Document Object Model（DOM）。

## 额外资源的加载
一个网站通常还会使用类似图片，样式文件和JavaScript代码等额外的资源。这些资源也需要从网络或缓存中获取。

## JavaScript会阻塞转化过程
当HTML分析器发现<script>标签时，会暂停接下来的HTML转化工作，然后加载、解析并且运行Javascript代码。因为在Javascript代码中可能会使用类似`document.write`这样的API去改变DOM的结构。这就是为什么HTML分析器必须等待Javascript代码运行结束才能继续分析的原因。

## 告诉浏览器要如何加载资源
如果我们的Javascript代码并不需要改变DOM，可以为<script>标签添加async或defer属性，这样浏览器就会异步的加载这些资源并且不会阻塞HTML转化过程。如果script标签是由JavaScript代码创建的，标签的async属性会默认为true。同时我们也可以使用一些预加载技术，比如<link ref="preload">来通知浏览器这些资源需要越快下载越好。

## 样式计算（Style calculation）

## 布局
布局树的结构与DOM树的结构十分相似，但只包含将会在页面中显示的元素。

当一个元素的样式被设置成display: none时，元素就不会出现在布局树中，但那些样式被设置成visiblility：hidden的元素会出现在布局树中。相似的，**当我们使用一个包含内容的伪元素（例如p::before { content: 'Hi!' }）时，元素会出现在布局树中即使这个元素不存在于DOM树中，这也是为什么我们使用DOM提供的API无法获取伪元素的原因**。

## 绘制
们知道图画中元素的尺寸、形状和位置，我们还需要知道绘制这些元素的顺序。

## 渲染过程是昂贵的

## 合成
浏览器已经知道了文档结构、每一个元素的样式，元素的几何信息，绘制的顺序。

将这些信息转化成屏幕上像素的过程叫做光栅化，光栅化是图形学的范畴。

传统的做法是将**可视区域的内容进行光栅化。随着用户滚动页面，不断的光栅化更多的区域。**然而对于现代浏览器，有着更复杂的的过程，这个过程被称做合成。

合成是一种将页面拆分成多层的技术，合成线程可以将各个层在不同线程中光栅化，再组合成一个页面。当滚动时，如果层已经被光栅化，则会使用已经存在的层合成新的帧，动画则可以通过移动层来实现。

## 层

## 栅格线程与合成线程
当布局树和绘制顺序确定以后，主线程会将这些信息提交给合成线程。合成线程会光栅化各个层。一个层包含的内容可能是一个完整的页面，也可能是页面的部分，所以合成线程将层拆分成许多块，并将它们发送给栅格线程。栅格线程光栅化这些块并将它们存储在GPU缓存中。

## 标记“慢滚动”区域


