在开始讲从输入url到显示在页面上发生了什么之前。让我们先了解一下浏览器的多进程架构，因为在当中涉及过程都是由各个进程相互配合，才得以完成的哦。

那么说到进程我们肯定还需要了解线程的概念了
# 进程和线程和协程
## 基本概念
进程是什么？
一个进程是应用正在运行的程序，当应用被启动的时候，进程就被创建出来了。操作系统会为进程分配私有的内存空间，当关闭程序时，这段内存也会被释放
线程是什么？
线程是进程中更小的部分，程序可以创建线程来帮助其工作
协程是什么？
协程是运行在线程中的更小的单位，async/await 就是基于协程实现的。

## 进程间通信 IPC
一个进程可以让操作系统开启另一个进程处理不同的任务，当两个进程需要通信时，可以用IPC

# 浏览器架构
以 Chrome 多进程架构进行说明吧，在Chrome 多进程架构中有不同的进程，他们负责自己的工作。

其中浏览器进程作为核心进程管理着其他的进程，而渲染进程赋值渲染不同的站点。

## 1、浏览器进程
- 负责管理Chrome 应用本身
- 地址栏、书签、前进和后退按钮
- 如网络请求、文件按访问等，也负责其他进程的调度
## 2、渲染进程
- 负责站点的渲染
- 包括 JavaScript 代码的运行
- web worker 的管理
## 3、插件进程
- 提供各种额外的插件功能，例如 flash
## 4、GPU进程
- GPU 进程负责提供成像的功能

## 多进程架构的好处
1、一个页面卡住没有关系，其他页面不是同一个进程中的，不会被阻塞
2、操作系统对进程安全的控制。浏览器可以将页面放在沙箱中，站点的代码可以运行在隔离的环境下，保证核心进程的安全

## 多进程的一些不足的地方
1、进程独享自己的私有内存
2、V8 引擎（用于解析和运行 Javascript），这意味着这部分相同的功能需要占用每个进程的内存空间
3、当使用多个页签访问相同的站点时浏览器不会创建新的渲染进程。

## 基于站点隔离的渲染进程
利用 iframe 我们可以在同一个页面访问不同站点的资源，但从安全的角度考虑，同源策略不允许一个站点在未得到同意的情况下访问其他站点的资源


每个站点由独立的渲染进程处理被默认启用。

# 浏览器进程
浏览器进程赋值除了渲染外的大部分工作，浏览器进程包括几个线程：
- UI线程绘制工具栏中的按钮、地址栏等
- 网络线程负责从网络中获取数据
- 存储线程负责文件等功能


当我们在地址栏中输入一个地址的时候，浏览器进程中的UI线程最先的到这个动作，并开始处理。

# 一次访问
## 1、输入处理
首先，UI线程会判断我们输入的内容是要搜索内容还是访问一个站点，因为地址栏同时也是一个搜索框。

## 2、访问开始
当按下回车键，UI线程将借助网络线程访问站点资源，浏览器页签的标题上会出现加载中的图标，同时网络线程会根据适当的网络协议，例如 DNS lookup 和 TLS 为这次请求建立连接。


当服务器返回给浏览器重定向请求时，网络线程会通知 UI 线程需要重定向，然后会以新的地址做开始请求资源。

## 3、处理响应的数据
当网络线程收到来自服务器的数据时，会试图从数据中的前面一些字节中得到数据的类型(Content-Type),了解数据的格式.

当返回的类型是html时，并且保证数据安全，通知UI线程会将数据传递给渲染进程进行渲染工作。但是如果数据类型是是 zip 文件或者其他文件格式时，会将数据传递给下载管理器做进一步的文件预览或者下载工作。

在开始渲染之前，网络进程要先检查一下数据的安全性，这里也是抱着浏览器安全的地方。
1. 返回的数据来自一些恶意的站点
2. Cross Origin Read Blocking(CORB)策略也会确保跨域的敏感数据不会被传递给渲染进程

## 4、渲染过程
Cross Origin Read Blocking(CORB)策略也会确保跨域的敏感数据不会被传递给渲染进程

网络线程通知UI线程数据已经准备好了，UI线程会根据当前的站点找到一个渲染进程完成下面的渲染工作。

## 5、提交访问

数据和渲染进程都已经准备好了，浏览器进程会通过 IPC 向渲染进程提交这次访问，同时也会保证渲染进程可以通过网络线程继续获取数据。一旦浏览器进程收到来自渲染进程的确认完毕的消息，就意味着访问的过程结束了，文档渲染的过程就开始了。

这时，地址栏显示出表明安全的图标，同时显示出站点的信息。访问历史中也会加入当前的站点信息。为了能恢复访问历史信息，当页签或窗口被关闭时，访问历史的信息会被存储在硬盘中。

## 6、加载完毕

## 7、渲染进程负责页面的内容

- 一个渲染进程中，主线程负责解析，编译或运行代码等工作，
- 当我们使用 Worker 时，Worker 线程会负责运行一部分代码。
- 合成线程和光栅线程是也是运行在渲染进程中的，负责更高效和顺畅的渲染页面


渲染进程最重要的工作就是将 HTML、CSS 和 Javascript 代码转换成一个可以与用户产生交互的页面。

解析过程
### 1、DOM创建
主线程开始解析 HTML 文本字符串，并且将其转化成 Document Object Model（DOM）

#### 额外资源加载

一个网站通常还会使用类似图片，样式文件和 JavaScript 代码等额外的资源。这些资源也需要从网络或缓存中获取。

#### JavaScript 会阻塞转化过程

当 HTML 分析器发现<script>标签时，会暂停接下来的 HTML 转化工作，然后加载、解析并且运行 Javascript 代码。因为在 Javascript 代码中可能会使用类似document.write这样的 API 去改变 DOM 的结构。这就是为什么 HTML 分析器必须等待 Javascript 代码运行结束才能继续分析的原因。

#### 告诉浏览器要如何加载资源
如果我们的 Javascript 代码并不需要改变 DOM，可以为<script>标签添加async或defer属性，这样浏览器就会异步的加载这些资源并且不会阻塞 HTML 转化过程。

如果 script 标签是由 JavaScript 代码创建的，标签的 async 属性会默认为 true。同时我们也可以使用一些预加载技术，比如<link ref="preload">来通知浏览器这些资源需要越快下载越好

### 2、样式计算
主线程会解析样式（CSS）并决定每个 DOM 元素的样式

### 3、布局
布局是为元素指定几何信息的过程。主线程遍历 DOM 结构中的元素及其样式，同时创建出带有坐标和元素尺寸信息的布局树（Layout tree）

- 只包含将会在页面中显示的元素
- 当一个元素的样式被设置成 display: none 时，元素就不会出现在布局树中
- 但那些样式被设置成 visiblility：hidden 的元素会出现在布局树中
- ，当我们使用一个包含内容的伪元素（例如p::before { content: 'Hi!' }）时，元素会出现在布局树中即使这个元素不存在于 DOM 树中，这也是为什么我们使用 DOM 提供的 API 无法获取伪元素的原因。

### 4、绘制
- DOM、样式和布局还是无法完成渲染工作
- 还需要知道绘制这些元素的顺序
- 主线程遍历布局树并创建绘制记录，绘制记录是一系列由绘制步骤组成的流程，例如先绘制背景，然后是文字，然后是形状。

### 5、渲染过程是昂贵的
- 当布局树改变时，绘制需要重构页面中变化的部分。
- 当一些元素有动画发生时，浏览器需要在每一帧中绘制这些元素
- 当无法保证每一帧绘制的连续性时，用户就会感觉到卡顿。

- 为了不影响渲染操作，我们可以将 Javascript 操作优化成小块，然后使用requestAnimationFrame()
- 当需要大量计算时，也可以使用 Worker 来避免阻塞主进程。

### 6、合成
浏览器已经知道了文档结构、每一个元素的样式，元素的几何信息，绘制的顺序。将这些信息转化成屏幕上像素的过程叫做光栅化，光栅化是图形学的范畴。
